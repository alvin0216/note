import{_ as s,o as a,c as e,Q as t}from"./chunks/framework.2c915ec2.js";const m=JSON.parse('{"title":"HTTP 报文结构是怎样的？","description":"","frontmatter":{"title":"HTTP 报文结构是怎样的？","date":"2018-09-22T13:00:28.000Z","sidebar":"auto","tags":["http"],"categories":["网络协议"]},"headers":[],"relativePath":"network-protocol/07.http报文结构.md","lastUpdated":1702473622000}'),o={name:"network-protocol/07.http报文结构.md"},n=t(`<p>对于 TCP 而言，在传输的时候分为两个部分: <strong>TCP 头</strong>和<strong>数据部分</strong>。</p><p>而 HTTP 类似，也是 <code>header + body</code> 的结构，具体而言:</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">起始行 </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> 头部 </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> 空行 </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> 实体</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><details class="details custom-block"><summary>Details</summary><p><img src="https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/http-wireshark.png" alt=""></p></details><h2 id="起始行" tabindex="-1">起始行 <a class="header-anchor" href="#起始行" aria-label="Permalink to &quot;起始行&quot;">​</a></h2><p>对于请求报文来说：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">GET </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">home HTTP</span><span style="color:#89DDFF;">/</span><span style="color:#F78C6C;">1.1</span></span>
<span class="line"></span></code></pre></div><p>也就是<code>方法</code> + <code>路径</code> + <code>http 版本</code>。</p><p>对于响应报文来说，起始行一般长这个样:</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">HTTP</span><span style="color:#89DDFF;">/</span><span style="color:#F78C6C;">1.1</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">200</span><span style="color:#A6ACCD;"> OK</span></span>
<span class="line"></span></code></pre></div><p><code>http 版本</code> + <code>状态码</code> + <code>原因</code>。</p><h2 id="头部" tabindex="-1">头部 <a class="header-anchor" href="#头部" aria-label="Permalink to &quot;头部&quot;">​</a></h2><p><img src="https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/response-header.png" alt=""></p><p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到 http 非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p><ul><li>字段名不区分大小写</li><li>字段名不允许出现空格，不可以出现下划线 <code>_</code></li><li>字段名后面必须紧接着 <code>:</code></li></ul><h2 id="空行" tabindex="-1">空行 <a class="header-anchor" href="#空行" aria-label="Permalink to &quot;空行&quot;">​</a></h2><p><code>空行</code> 用于区分<strong>头部</strong>和<strong>实体</strong></p><div class="warning custom-block"><p class="custom-block-title">如果说在头部中间故意加一个空行会怎么样？</p><p>那么空行后的内容全部被视为实体。</p></div><h2 id="实体" tabindex="-1">实体 <a class="header-anchor" href="#实体" aria-label="Permalink to &quot;实体&quot;">​</a></h2><p>就是具体的数据了，也就是 body 部分。请求报文对应请求体, 响应报文对应响应体。</p>`,20),l=[n];function p(c,r,i,d,h,C){return a(),e("div",null,l)}const u=s(o,[["render",p]]);export{m as __pageData,u as default};
