import{_ as t,o as e,c as r,Q as a}from"./chunks/framework.2c915ec2.js";const S=JSON.parse('{"title":"TCP 四次挥手的过程","description":"","frontmatter":{"title":"TCP 四次挥手的过程","date":"2018-09-28T16:00:28.000Z","sidebar":"auto","tags":["tcp"],"categories":["网络协议"]},"headers":[],"relativePath":"network-protocol/04.tcp四次挥手.md","lastUpdated":1716905716000}'),o={name:"network-protocol/04.tcp四次挥手.md"},d=a('<p>四次挥手即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。</p><p><img src="https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/wave.png" alt=""></p><h2 id="挥手过程" tabindex="-1">挥手过程 <a class="header-anchor" href="#挥手过程" aria-label="Permalink to &quot;挥手过程&quot;">​</a></h2><p>假设客户端发起关闭连接请求</p><table><thead><tr><th style="text-align:center;">挥手</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center;">1️⃣</td><td>客户端发送 <code>FIN,ACK</code> 包给服务端，告诉他我要关闭请求了，此时进入 <code>FIN_WAIT</code> 状态</td></tr><tr><td style="text-align:center;">2️⃣</td><td>服务端接收到关闭请求后，发送 <code>ACK</code> 包给客户端，告诉他我知道了。<br> 但是我还不确定数据传输完了没，等我确定或者处理完，我这边就发个关闭请求包给你。<br>此时客户端进入 <code>FIN_WAIT2</code> 状态，服务端进入 <code>CLOSE_WAIT</code> 状态</td></tr><tr><td style="text-align:center;">3️⃣</td><td>服务端传输完数据了，发送 <code>FIN,ACK</code> 给客户端，告诉他 我传输完数据了，你可以关闭了。</td></tr><tr><td style="text-align:center;">4️⃣</td><td>客户端收到服务端的关闭请求包后，发送 <code>ACK</code> 包给服务端，告诉他我知道了，你可以关闭了。<br> 服务端收到后，则进入 <code>CLOSED</code> 状态。<br> 由于不确定服务端是否关闭了，客户端还需等待 <code>2MSL</code> 后才关闭连接</td></tr></tbody></table><h2 id="挥手为什么需要四次" tabindex="-1">挥手为什么需要四次？ <a class="header-anchor" href="#挥手为什么需要四次" aria-label="Permalink to &quot;挥手为什么需要四次？&quot;">​</a></h2><p>由于 TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP 是<strong>全双工模式</strong>。</p><p>这就意味着，关闭连接时，当 Client 端发出 FIN 报文段时，只是表示 Client 端告诉 Server 端数据已经发送完毕了。</p><p>当 Server 端收到 FIN 报文并返回 ACK 报文段，表示它已经知道 Client 端没有数据发送了，但是 Server 端还是可以发送数据到 Client 端的，所以 Server 很可能并不会立即关闭 SOCKET，直到 Server 端把数据也发送完毕。</p><p>当 Server 端也发送了 FIN 报文段时，这个时候就表示 Server 端也没有数据要发送了，就会告诉 Client 端，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。</p><h2 id="四次挥手释放连接时-等待-2msl-的意义" tabindex="-1">四次挥手释放连接时，等待 2MSL 的意义? <a class="header-anchor" href="#四次挥手释放连接时-等待-2msl-的意义" aria-label="Permalink to &quot;四次挥手释放连接时，等待 2MSL 的意义?&quot;">​</a></h2><p>如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。 那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?</p><ul><li><strong>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端</strong></li><li><strong>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达</strong></li></ul><p>这就是等待 2MSL 的意义。</p>',14),c=[d];function n(l,s,i,p,_,h){return e(),r("div",null,c)}const T=t(o,[["render",n]]);export{S as __pageData,T as default};
