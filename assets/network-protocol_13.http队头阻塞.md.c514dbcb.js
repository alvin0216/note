import{_ as t,o as e,c as a,Q as o}from"./chunks/framework.2c915ec2.js";const T=JSON.parse('{"title":"如何解决 HTTP 的队头阻塞问题？","description":"","frontmatter":{"title":"如何解决 HTTP 的队头阻塞问题？","date":"2018-09-15T13:00:28.000Z","sidebar":"auto","tags":["http","队头阻塞"],"categories":["网络协议"]},"headers":[],"relativePath":"network-protocol/13.http队头阻塞.md","lastUpdated":1717165734000}'),r={name:"network-protocol/13.http队头阻塞.md"},n=o('<h2 id="什么是队头阻塞" tabindex="-1">什么是队头阻塞 <a class="header-anchor" href="#什么是队头阻塞" aria-label="Permalink to &quot;什么是队头阻塞&quot;">​</a></h2><p><strong>http1.x 采用长连接(Connection:keep-alive)，可以在一个 TCP 请求上，发送多个 http 请求。</strong></p><p>因为 HTTP 规定报文必须是 “<strong>一发一收</strong>”，这就形成了一个先进先出的“串行”队列。</p><p>队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</p><p>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</p><h2 id="并发连接" tabindex="-1">并发连接 <a class="header-anchor" href="#并发连接" aria-label="Permalink to &quot;并发连接&quot;">​</a></h2><p>浏览器一个域名采用 <code>6-8</code> 个 TCP 连接，并发 <code>HTTP</code> 请求.</p><p>但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</p><h2 id="域名分片" tabindex="-1">域名分片 <a class="header-anchor" href="#域名分片" aria-label="Permalink to &quot;域名分片&quot;">​</a></h2><p>一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。比如 content1.alvin.run 、content2.alvin.run。</p><p>这样一个 <code>alvin.run</code> 域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p><div class="danger custom-block"><p class="custom-block-title">http1.1 没有真正解决了队头阻塞问题</p><p>即使使用上面的方式，也是治标不治本，http2 采用了<strong>多路复用的方式</strong>解决了这个问题，请看后续。</p></div>',12),c=[n];function p(s,i,d,l,_,h){return e(),a("div",null,c)}const m=t(r,[["render",p]]);export{T as __pageData,m as default};
