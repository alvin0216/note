import{_ as t,o,c as a,N as e,x as c}from"./chunks/framework.208f6f3f.js";const m=JSON.parse('{"title":"三次握手的过程是怎样的？","description":"","frontmatter":{"title":"三次握手的过程是怎样的？","date":"2018-09-15T13:00:28.000Z","sidebar":"auto","tags":["tcp","三次握手"],"categories":["网络协议"]},"headers":[],"relativePath":"network-protocol/03.tcp三次握手.md","lastUpdated":1681197312000}'),d={name:"network-protocol/03.tcp三次握手.md"},s=e('<p>TCP 的三次握手，也是需要确认双方的两样能力: 发送的能力和接收的能力。于是便会有下面的三次握手的过程:</p><p><img src="https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/shake-hand.png" alt=""></p><h2 id="握手过程" tabindex="-1">握手过程 <a class="header-anchor" href="#握手过程" aria-label="Permalink to &quot;握手过程&quot;">​</a></h2><p>刚开始客户端处于 <code>Closed</code> 的状态，服务端处于 <code>Listen</code> 状态。 进行三次握手：</p><table><thead><tr><th>握手</th><th>描述</th></tr></thead><tbody><tr><td>1️⃣</td><td>客户端给服务端发一个 <code>SYN</code> 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 <code>SYN_SEND</code> 状态。</td></tr><tr><td>2️⃣</td><td>服务器收到客户端的 SYN 报文之后，会以自己的 <code>SYN + ACK</code> 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。 同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <code>SYN_REVD</code> 的状态。</td></tr><tr><td>3️⃣</td><td>客户端收到 SYN 报文之后，会发送一个 <code>ACK</code> 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</td></tr></tbody></table><p>从图中可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加 1，为什么呢？只需要记住一个规则:</p><p><strong>凡是需要对端确认的，一定消耗 TCP 报文的序列号。</strong></p><p>SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。</p><h2 id="为什么需要三次握手-两次不行吗" tabindex="-1">为什么需要三次握手，两次不行吗？ <a class="header-anchor" href="#为什么需要三次握手-两次不行吗" aria-label="Permalink to &quot;为什么需要三次握手，两次不行吗？&quot;">​</a></h2><p>试想如果是用两次握手，则会出现下面这种情况：</p><p>如果是两次，你现在发了 SYN 报文想握手，但<strong>是这个包滞留在了当前的网络中</strong>迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。</p><p>看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。</p><p>看到问题的吧，这就带来了连接资源的浪费。</p><h2 id="三次握手过程中可以携带数据吗" tabindex="-1">三次握手过程中可以携带数据吗？ <a class="header-anchor" href="#三次握手过程中可以携带数据吗" aria-label="Permalink to &quot;三次握手过程中可以携带数据吗？&quot;">​</a></h2><p><strong>第三次握手的时候，可以携带。前两次握手不能携带数据。</strong></p><p>如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。</p><p>第三次握手的时候，客户端已经处于 <code>ESTABLISHED</code> 状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。</p><h2 id="同时打开会怎样" tabindex="-1">同时打开会怎样？ <a class="header-anchor" href="#同时打开会怎样" aria-label="Permalink to &quot;同时打开会怎样？&quot;">​</a></h2><p>如果双方同时发 <code>SYN</code> 报文，状态变化会是怎样的呢？</p><p>这是一个可能会发生的情况。</p><p>状态变迁如下:</p>',21),p=c("img",{className:"small",alt:"",src:"https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/tcp-connection.png"},null,-1),r=e("<p>在发送方给接收方发 <code>SYN</code> 报文的同时，接收方也给发送方发 <code>SYN</code> 报文，两个人刚上了!</p><p>发完 SYN，两者的状态都变为 <code>SYN-SENT</code>。</p><p>在各自收到对方的 <code>SYN</code> 后，两者状态都变为 <code>SYN-REVD</code>。</p><p>接着会回复对应的 <code>ACK + SYN</code>，这个报文在对方接收之后，两者状态一起变为 <code>ESTABLISHED</code>。</p><p>这就是同时打开情况下的状态变迁。</p>",5),n=[s,p,r];function _(i,S,l,h,N,T){return o(),a("div",null,n)}const A=t(d,[["render",_]]);export{m as __pageData,A as default};
