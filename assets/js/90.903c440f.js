(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{663:function(e,r,t){"use strict";t.r(r);var n=t(6),a=Object(n.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("ol",[t("li",[e._v("开发过程可视化。可视化交互是低代码平台所具备的一种必备能力，不再面对冷冰冰的传统文本 IDE 编辑器，转而和可视化的编辑器进行交互，不管是 UI 界面，交互事件、后端接口、数据库/Redis 调用，都能通过优雅而简单的可视化交互完成配置和编辑。")]),e._v(" "),t("li",[e._v("代码开发组件化。这个能力和中台化、SDK 的概念有相似之处，就是将重复的公共的能力沉淀出来，封装起来，让开发人员可以在低代码平台上，直接拿出来作为工具嵌到产品中，这样开发者就不用再关心这个功能/组件的内部实现。")]),e._v(" "),t("li",[e._v("一次开发，多端发布。对于前端研发人员来说，经常需要多端发布同一个项目/页面，H5/小程序/IOS/Android 的开发工作，经常需要不同技术栈的研发人员。而对于低代码，就屏蔽了具体的代码选型，内部编辑都用一种低代码语言，最后发布上线，可以发布到小程序/安卓/IOS 等多个端，而且能尽量保证 UI、交互、功能的一致性。")])]),e._v(" "),t("h2",{attrs:{id:"相关资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关资料"}},[e._v("#")]),e._v(" 相关资料")]),e._v(" "),t("ul",[t("li",[e._v("相关资料\n"),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6959794588898820127",target:"_blank",rel:"noopener noreferrer"}},[e._v("【阿里巴巴淘系技术】前端智能化看“低代码/无代码”"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/taowen/awesome-lowcode",target:"_blank",rel:"noopener noreferrer"}},[e._v("国内低代码平台"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/jS1_axYqFkngwRLwz48FwA",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何设计实现 H5 营销页面搭建系统"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/O3VvId5xMWrRjug8S-yq_A",target:"_blank",rel:"noopener noreferrer"}},[e._v("花椒低代码可视化编辑平台的设计与实践"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6938340932408311845",target:"_blank",rel:"noopener noreferrer"}},[e._v("【React 个人版】H5 活动页面快速生成神器——Mocha"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6844904155220279303",target:"_blank",rel:"noopener noreferrer"}},[e._v("【React 个人版】react 打造页面可视化搭建 1 - 提纲 持续更新"),t("OutboundLink")],1)])])]),e._v(" "),t("li",[e._v("拖拽\n"),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6908502083075325959",target:"_blank",rel:"noopener noreferrer"}},[e._v("可视化拖拽组件库一些技术要点原理分析"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6918881497264947207",target:"_blank",rel:"noopener noreferrer"}},[e._v("可视化拖拽组件库一些技术要点原理分析（二）"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6929302655118344200",target:"_blank",rel:"noopener noreferrer"}},[e._v("可视化拖拽组件库一些技术要点原理分析（三）"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6933385955789406222",target:"_blank",rel:"noopener noreferrer"}},[e._v("可视化搭建平台之跨 iframe 拖拽"),t("OutboundLink")],1)])])]),e._v(" "),t("li",[e._v("动态物料\n"),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6924829595006926856",target:"_blank",rel:"noopener noreferrer"}},[e._v("动态表单之表单组件的插件式加载方案"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://zh-hans.single-spa.js.org/docs/getting-started-overview",target:"_blank",rel:"noopener noreferrer"}},[e._v("微前端 动态加载远程组件"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/y805939188/react-vue-micro-frame",target:"_blank",rel:"noopener noreferrer"}},[e._v("react-vue-micro-frame"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://xie.infoq.cn/article/2eac85154f18010da98cb8301",target:"_blank",rel:"noopener noreferrer"}},[e._v("揭秘 vivo 如何打造千万级 DAU 活动中台 - 启航篇"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://stackoverflow.com/questions/54763605/vue-js-is-it-possible-to-use-javascript-dynamic-imports-to-load-components-fro",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.js - Is it possible to use Javascript Dynamic Imports to load components from another server?"),t("OutboundLink")],1)])])]),e._v(" "),t("li",[e._v("案例\n"),t("ul",[t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/90746742",target:"_blank",rel:"noopener noreferrer"}},[e._v("云凤蝶可视化搭建的推导与实现"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/78425921",target:"_blank",rel:"noopener noreferrer"}},[e._v("云凤蝶中台研发提效实践"),t("OutboundLink")],1)])])])]),e._v(" "),t("h2",{attrs:{id:"实现点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现点"}},[e._v("#")]),e._v(" 实现点")]),e._v(" "),t("p",[e._v("基于原型对项目设计进行了功能的铺平，其实还是围绕"),t("strong",[e._v("组件、画布、属性面板")]),e._v("这三块。")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("moda-decoreate：也即编辑器的设计思路")]),e._v(" "),t("ul",[t("li",[e._v("画布区域如何渲染已添加到画布中的组件（组件库组件会很多，画布中可能只需添加几个组件，考虑如何做动态渲染）？")]),e._v(" "),t("li",[e._v("组件从左侧拖入画布区域，选中组件，就可知道该组件关联的属性。组件 Schema 如何设计？")]),e._v(" "),t("li",[e._v("画布区域和预览时组件的渲染是否可共用一套渲染逻辑？")]),e._v(" "),t("li",[e._v("组件的数据如何去维护（考虑添加组件、删除组件、组件渲染/预览等场景）")]),e._v(" "),t("li",[e._v("组件库如何维护（考虑新增组件满足业务需要的场景）")]),e._v(" "),t("li",[e._v("如何做到纯组件")])])]),e._v(" "),t("li",[t("strong",[e._v("物料市场如何设计")]),e._v(" "),t("ul",[t("li",[e._v("如何动态加载组件，"),t("strong",[e._v(">> 插拔式的设计，我们希望添加新的自定义组件之后可以不需要重新发布项目，只需要单独发布自定义组件，然后在系统中注册该自定义组件，就能在配置页面的时候直接使用了。")])]),e._v(" "),t("li",[e._v("提供物料生成的方式，这里我采用的是通过开发 node 交互式的脚本命令，将打包后的 umd 文件快速上传到物料市场。")])])]),e._v(" "),t("li",[t("strong",[e._v("进阶")]),e._v(" "),t("ul",[t("li",[e._v("如何基于可视化底盘去探索 10 倍效能提升？")])])])]),e._v(" "),t("h3",{attrs:{id:"schema-如何设计存放在哪里"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#schema-如何设计存放在哪里"}},[e._v("#")]),e._v(" schema 如何设计存放在哪里？")]),e._v(" "),t("h3",{attrs:{id:"如何设计物料市场"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何设计物料市场"}},[e._v("#")]),e._v(" 如何设计物料市场？")]),e._v(" "),t("p",[e._v("分为前中后期。")]),e._v(" "),t("ul",[t("li",[e._v("前期实现如 npm 包导入的方式，缺点是无法实现运行时加载，而且编辑器需要频繁打包。")]),e._v(" "),t("li",[e._v("中期：将编辑器打包出去，当作组件包的方式给予开发者使用，优点开发者可以随意插入物料和自定义组件，只是复用编辑器的逻辑产生 renderData，")]),e._v(" "),t("li",[e._v("后期：通过动态加载的方式，使得编辑器的兼容性更强，不需要再重复打包而且高复用物料市场。")])]),e._v(" "),t("h3",{attrs:{id:"如何快速开发物料-并上传到物料市场"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何快速开发物料-并上传到物料市场"}},[e._v("#")]),e._v(" 如何快速开发物料，并上传到物料市场？")]),e._v(" "),t("p",[e._v("这里我的思路是：开发一个 cli 工具，读取组件 package.json。上传打包好的组件到物料市场，name+version 目前增量式的增加物料。")]),e._v(" "),t("h3",{attrs:{id:"物料如何动态渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#物料如何动态渲染"}},[e._v("#")]),e._v(" 物料如何动态渲染？")]),e._v(" "),t("p",[e._v("这里分为"),t("code",[e._v("编译时加载")]),e._v("和"),t("code",[e._v("运行时加载")]),e._v("，如 React 在 umi 下有 "),t("code",[e._v("dynamic")]),e._v(" ，底层其实也是 "),t("code",[e._v("webpack code splitting")]),e._v("，进行代码分割，而 vue 也可以通过 "),t("code",[e._v('<component :is="ComponantName" />')]),e._v("，而这些在编译时就必须存在，好处就是内置，加载快，上手成本低。")]),e._v(" "),t("p",[e._v("而在业务频繁迭代过程中，"),t("strong",[e._v("是否每修改一次组件，就要去重新打包项目 发个版本呢？")]),e._v(" 这是需要考虑到的一点，所以运行时加载尤其重要。")]),e._v(" "),t("p",[e._v("这里我有两个方面去设计，第一通过微前端的方式进行载入，由于我掌握的知识有限，所以并未实现下去。第二，通过 UMD 的方式动态载入组件，这一点倒是实现了。")]),e._v(" "),t("p",[e._v("继续思考，一个页面如果有 10 个物料的话，是不是就得动态加载 10 个静态资源呢，如果每个组件都有一个 JS，一个 CSS。那就是 20 个。这是不具备可行性的。所以就有了物料合并的需求。")]),e._v(" "),t("p",[e._v("如何做呢？用户通过在注册的 code，然后关联相关物料，这个时候就可以确认当前 code 有什么物料了，此时我们只需要在配一个后端，监听到物料集合修改后针对性统一打包就可以了。不过也是风险极高，这得约定好打包的配置是一致的。")])])}),[],!1,null,null,null);r.default=a.exports}}]);