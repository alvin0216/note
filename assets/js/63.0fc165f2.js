(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{731:function(t,v,_){"use strict";_.r(v);var a=_(3),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"什么是队头阻塞"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是队头阻塞"}},[t._v("#")]),t._v(" 什么是队头阻塞")]),t._v(" "),_("p",[_("strong",[t._v("http1.x 采用长连接(Connection:keep-alive)，可以在一个 TCP 请求上，发送多个 http 请求。")])]),t._v(" "),_("p",[t._v("因为 HTTP 规定报文必须是 “"),_("strong",[t._v("一发一收")]),t._v("”，这就形成了一个先进先出的“串行”队列。")]),t._v(" "),_("p",[t._v("队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。")]),t._v(" "),_("p",[t._v("如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。")]),t._v(" "),_("h2",{attrs:{id:"并发连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发连接"}},[t._v("#")]),t._v(" 并发连接")]),t._v(" "),_("p",[t._v("浏览器一个域名采用 "),_("code",[t._v("6-8")]),t._v(" 个 TCP 连接，并发 "),_("code",[t._v("HTTP")]),t._v(" 请求.")]),t._v(" "),_("p",[t._v("但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。")]),t._v(" "),_("h2",{attrs:{id:"域名分片"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#域名分片"}},[t._v("#")]),t._v(" 域名分片")]),t._v(" "),_("p",[t._v("一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。比如 content1.alvin.run 、content2.alvin.run。")]),t._v(" "),_("p",[t._v("这样一个 "),_("code",[t._v("alvin.run")]),t._v(" 域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。")]),t._v(" "),_("div",{staticClass:"custom-block danger"},[_("p",{staticClass:"custom-block-title"},[t._v("http1.1 没有真正解决了队头阻塞问题")]),t._v(" "),_("p",[t._v("即使使用上面的方式，也是治标不治本，http2 采用了"),_("strong",[t._v("多路复用的方式")]),t._v("解决了这个问题，请看后续。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);