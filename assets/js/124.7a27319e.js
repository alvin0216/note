(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{688:function(t,e,v){"use strict";v.r(e);var _=v(6),r=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("Diff 算法：基本概念、更新时机 、遍历算法、优化策略")]),t._v(" "),v("h2",{attrs:{id:"基本概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),v("p",[v("strong",[t._v("（基本概念）")]),t._v(" diff 算法是建立在虚拟 dom 的基础上的，diff 算法探讨的就是虚拟 dom 发生变化之后生成 dom 树更新补丁的方式，通过对比新旧虚拟 dom 的方式，将更新 patch 补丁作用到真实 dom 中，以最小的成本完成视图更新。")]),t._v(" "),v("p",[v("strong",[t._v("（大概流程）")]),t._v(" 首先真实的 dom 会映射到虚拟 dom 中，当虚拟 dom 发生变化后，会根据差异计算生成 patch、包括新增、删除、更新。")]),t._v(" "),v("h2",{attrs:{id:"更新时机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#更新时机"}},[t._v("#")]),t._v(" 更新时机")]),t._v(" "),v("p",[t._v("更新时机：setState、hooks 等")]),t._v(" "),v("h2",{attrs:{id:"遍历算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#遍历算法"}},[t._v("#")]),t._v(" 遍历算法")]),t._v(" "),v("p",[t._v("遍历算法：深度优先遍历，从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止然后回溯前一个节点，进行右子树节点遍历，直到遍历完所有可达节点")]),t._v(" "),v("p",[v("strong",[t._v("为什么用深度不用广度")]),t._v("：虽然深度优先遍历保证了组件的生命周期时序不错乱，但传统的 diff 算法带来一个严重的性能瓶颈，复杂程度为 0(n^3),其中 n 表示树的节点总数")]),t._v(" "),v("p",[t._v("React 用了一个非常经典的手法将复杂度降低为 0(n)就是分治，即通过“分而治之”这一-巧妙的思想分解问题")]),t._v(" "),v("h2",{attrs:{id:"优化策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优化策略"}},[t._v("#")]),t._v(" 优化策略")]),t._v(" "),v("p",[t._v("具体而言 react 从 "),v("code",[t._v("树")]),t._v(" "),v("code",[t._v("组件")]),t._v(" "),v("code",[t._v("元素")]),t._v(" 三个层面进行优化")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://user-images.githubusercontent.com/34113677/158239575-a5262d59-9bff-400f-a507-116aada46082.png",alt:""}})]),t._v(" "),v("p",[v("strong",[t._v("策略一:忽略节点跨层级操作场景，提升比对效率")])]),t._v(" "),v("p",[t._v("需进行树比对，即对树进行分层比较两棵树只对同一层次节点进行比较，如发现节点已不存在则该节点及其子节点会被完全删除，不会用于进一步比较，提升了比对效率")]),t._v(" "),v("p",[v("strong",[t._v("策略二:如果组件的 class 一致，则默认为相似的树结构否则默认为不同的树结构")])]),t._v(" "),v("p",[t._v("如果组件是同一类型则进行树比对如果不是则直接放入补丁中。这也是 "),v("code",[t._v("shouldComponentUpdate")]),t._v(" "),v("code",[t._v("React.memo")]),t._v(" 能提高性能的原因。")]),t._v(" "),v("p",[v("strong",[t._v("策略三:同一层级子节点，可通过标记 key 的方式进行列表对比")])]),t._v(" "),v("p",[t._v("元素比对主要发生在同层级中，通过标记节点操作生成补丁节点操作包含了插入、移动、删除等")]),t._v(" "),v("p",[v("strong",[t._v("除此之外，还采用了双缓冲机制")])]),t._v(" "),v("ul",[v("li",[t._v("Fiber 机制下节点与树分别采用 FiberNode 与 FiberTree 进行重构\n"),v("ul",[v("li",[t._v("FiberNode 是采用了双链表的结构、可以直接找到兄弟节点和字节点，使得整个更新过程可以随时暂停恢复")]),t._v(" "),v("li",[t._v("FiberTree 则是通过 FiberNode 生成的树。")])])]),t._v(" "),v("li",[t._v("Fiber 机制下整个更新过程由 current 与 workInProgress 两株树双缓冲完成\n"),v("ul",[v("li",[t._v("当 workInProgress 树更新完成后，会将 current 指针指向 workInProgress")])])])]),t._v(" "),v("h2",{attrs:{id:"了解-diff-算法-我们该怎么做"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#了解-diff-算法-我们该怎么做"}},[t._v("#")]),t._v(" 了解 diff 算法，我们该怎么做")]),t._v(" "),v("ul",[v("li",[t._v("根据 diff 算法的设计原则,应尽量避免跨层级节点移动。")]),t._v(" "),v("li",[t._v("通过设置唯一 key 进行优化，尽量减少组件层级深度，因为过深的层级会加深遍历深度，带来性能问题。")]),t._v(" "),v("li",[t._v("设置 shouldComponentUpdate 或者 React.pureComponet 减少 diff 次数")])])])}),[],!1,null,null,null);e.default=r.exports}}]);