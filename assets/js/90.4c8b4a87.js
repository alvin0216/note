(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{688:function(t,a,s){"use strict";s.r(a);var e=s(7),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"主要过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主要过程"}},[t._v("#")]),t._v(" 主要过程")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png",alt:""}})]),t._v(" "),s("ol",[s("li",[t._v("构建 DOM 树："),s("strong",[t._v("渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。")])]),t._v(" "),s("li",[t._v("构建 CSS 树："),s("strong",[t._v("渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。")]),t._v(" "),s("ul",[s("li",[t._v("把 "),s("code",[t._v("link")]),t._v(" "),s("code",[t._v("<style>")]),t._v(" "),s("code",[t._v("style")]),t._v(" 包含的 CSS 转换为浏览器能够理解的结构")]),t._v(" "),s("li",[t._v("转换样式表中的属性值，使其标准化 比如 "),s("code",[t._v("red -> rgb(255, 0, 0)")]),t._v(" "),s("code",[t._v("1em -> 16px")])]),t._v(" "),s("li",[t._v("计算出 DOM 树中每个节点的具体样式，涉及到 CSS 的继承规则和层叠规则")])])])]),t._v(" "),s("ul",[s("li",[t._v("layout 阶段："),s("strong",[t._v("创建布局树，并计算元素的布局信息")])]),t._v(" "),s("li",[t._v("分层："),s("strong",[t._v("浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面")])]),t._v(" "),s("li",[t._v("绘制 阶段\n"),s("ul",[s("li",[t._v("为每个图层生成绘制列表，并将其提交到合成线程")]),t._v(" "),s("li",[t._v("合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。")]),t._v(" "),s("li",[t._v("合成线程发送绘制图块命令 DrawQuad 给浏览器进程。")]),t._v(" "),s("li",[t._v("浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。")])])])]),t._v(" "),s("h2",{attrs:{id:"重排"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重排"}},[t._v("#")]),t._v(" 重排")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png",alt:""}})]),t._v(" "),s("p",[t._v("如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。"),s("strong",[t._v("无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。")])]),t._v(" "),s("h2",{attrs:{id:"重绘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png",alt:""}})]),t._v(" "),s("p",[t._v("从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，")]),t._v(" "),s("h2",{attrs:{id:"css-动画为什么能提高渲染性能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-动画为什么能提高渲染性能"}},[t._v("#")]),t._v(" css 动画为什么能提高渲染性能")]),t._v(" "),s("p",[s("strong",[t._v("直接合成阶段")])]),t._v(" "),s("p",[t._v("那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png",alt:""}})]),t._v(" "),s("p",[t._v("在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，"),s("strong",[t._v("所以相对于重绘和重排，合成能大大提升绘制效率。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);