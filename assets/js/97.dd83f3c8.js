(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{894:function(e,t,a){"use strict";a.r(t);var f=a(3),r=Object(f.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6867745889184972814",target:"_blank",rel:"noopener noreferrer"}},[e._v("烤透 React Hook"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6844904127110053895",target:"_blank",rel:"noopener noreferrer"}},[e._v("用动画和实战打开 React Hooks（一）：useState 和 useEffect"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://react.iamkasong.com/hooks/useeffect.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("iamkasong useEffect"),a("OutboundLink")],1)])]),e._v(" "),a("p",[e._v("请自行翻阅源码")]),e._v(" "),a("p",[e._v("一个使用 useEffect Hook 的函数组件，在运行的时候的运行流程如下：")]),e._v(" "),a("h2",{attrs:{id:"组件初次渲染-挂载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件初次渲染-挂载"}},[e._v("#")]),e._v(" 组件初次渲染（挂载）")]),e._v(" "),a("ul",[a("li",[e._v("执行 useEffect 时，将 useEffect Hook 添加到 Hook 链表中，然后创建 fiberNode 的 updateQueue，并把本次 effect 添加到 updateQueue 中；")]),e._v(" "),a("li",[e._v("渲染组件的 UI；")]),e._v(" "),a("li",[e._v("完成 UI 渲染后，执行本次 effect；")])]),e._v(" "),a("h2",{attrs:{id:"组件重新渲染-更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件重新渲染-更新"}},[e._v("#")]),e._v(" 组件重新渲染（更新）")]),e._v(" "),a("ol",[a("li",[e._v("执行 useEffect 时，将 useEffect Hook 添加到 Hook 链表中，判断依赖：\n"),a("ul",[a("li",[e._v("假如没有传入依赖（useEffect 没有传入第二个参数），那么直接给这个 effect 打上 “需要执行” 的 tag（HookHasEffect）；")]),e._v(" "),a("li",[e._v("假如有传入依赖 deps 并且当前依赖和上次渲染时的依赖对比有发生改变，那么就给这个 effect 打上 “需要执行” 的 tag（HookHasEffect）；")]),e._v(" "),a("li",[e._v("假如有传入依赖 deps，但是依赖没有发生改变，则 不会 给这个 effect “需要执行” 的 tag；")]),e._v(" "),a("li",[e._v("假如有传入依赖 deps，但是传入的是一个空数组 []，那么也 不会 给这个 effect “需要执行” 的 tag；")])])]),e._v(" "),a("li",[e._v("渲染组件的 UI；")]),e._v(" "),a("li",[e._v("假如有清除函数（effect 中的 return 内容），则执行上一次渲染的清除函数；如果依赖是 []，则先不用执行清除函数，而是等到组件销毁时才执行；")]),e._v(" "),a("li",[e._v("判断本次 effect 是否有“需要执行” 的 tag（HookHasEffect），如果有，就执行本次 effect；如果没有，就直接跳过，不执行 本次 effect；")])]),e._v(" "),a("h2",{attrs:{id:"组件销毁时"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件销毁时"}},[e._v("#")]),e._v(" 组件销毁时")]),e._v(" "),a("p",[e._v("在组件销毁之前，先执行完组件上次渲染时的清除函数")])])}),[],!1,null,null,null);t.default=r.exports}}]);