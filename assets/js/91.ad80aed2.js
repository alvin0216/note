(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{690:function(e,o,s){"use strict";s.r(o);var v=s(7),_=Object(v.a)({},(function(){var e=this,o=e.$createElement,s=e._self._c||o;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("ul",[s("li",[s("code",[e._v("cookie")]),e._v(" 指的就是浏览器里面能存储的一种数据，仅仅是浏览器实现的一种数据存储功能。"),s("code",[e._v("cookie")]),e._v(" 由服务器生成，发送给浏览器，浏览器以 "),s("code",[e._v("key-value")]),e._v(" 形式保存到某个目录下的文本文件内，下次请求同一站点的网站时会把 "),s("code",[e._v("cookie")]),e._v(" 发送到浏览器。由于 "),s("code",[e._v("cookie")]),e._v(" 是存在客户端上的，所以浏览器加入了一些限制，确保 "),s("code",[e._v("cookie")]),e._v(" 不被恶意使用，以及限制了大小。")]),e._v(" "),s("li",[s("code",[e._v("session")]),e._v(" 从字面上讲就是会话，服务器要知道当前发送请求的是谁，因此需要给每个客户端分配不同的身份标识，然后客户端每次香服务器请求的时候，都通过这个身份标识确认身份。一般 sessionId 是存储在 cookie 里面的。\n"),s("ul",[s("li",[s("code",[e._v("session")]),e._v(" 的问题还有前端的 sessionId 是可以伪造的，所以还需要在服务器维护一个 "),s("code",[e._v("sessionId")]),e._v(" 的白名单来验证 "),s("code",[e._v("sessionId")]),e._v(" 的合法性, "),s("code",[e._v("token")]),e._v(" 的改进之处就在这里")])])]),e._v(" "),s("li",[s("code",[e._v("token")]),e._v(" 通过签名机制，只要前端传来的 token 能通过签名认证就是合法的，不需要服务器维护任何东西")])])])}),[],!1,null,null,null);o.default=_.exports}}]);