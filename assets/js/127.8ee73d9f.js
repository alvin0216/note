(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{698:function(_,v,e){"use strict";e.r(v);var t=e(6),s=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("p",[_._v("TLS 1.2 虽然存在了 10 多年，经历了无数的考验，但历史的车轮总是不断向前的，为了获得更强的安全、更优秀的性能，在 2018 年就推出了 TLS1.3，对于 TLS1.2 做了一系列的改进，主要分为这几个部分:强化安全、提高性能。")]),_._v(" "),e("h2",{attrs:{id:"强化安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强化安全"}},[_._v("#")]),_._v(" 强化安全")]),_._v(" "),e("p",[_._v("在 TLS1.3 中废除了非常多的加密算法，最后只保留五个加密套件:")]),_._v(" "),e("ul",[e("li",[_._v("TLS_AES_128_GCM_SHA256")]),_._v(" "),e("li",[_._v("TLS_AES_256_GCM_SHA384")]),_._v(" "),e("li",[_._v("TLS_CHACHA20_POLY1305_SHA256")]),_._v(" "),e("li",[_._v("TLS_AES_128_GCM_SHA256")]),_._v(" "),e("li",[_._v("TLS_AES_128_GCM_8_SHA256")])]),_._v(" "),e("p",[_._v("可以看到，最后剩下的对称加密算法只有 "),e("code",[_._v("AES")]),_._v(" 和 "),e("code",[_._v("CHACHA20")]),_._v("，之前主流的也会这两种。分组模式也只剩下 "),e("code",[_._v("GCM")]),_._v(" 和 "),e("code",[_._v("POLY1305")]),_._v(", 哈希摘要算法只剩下了 "),e("code",[_._v("SHA256")]),_._v(" 和 "),e("code",[_._v("SHA384")]),_._v(" 了。")]),_._v(" "),e("h3",{attrs:{id:"那你可能会问了-之前-rsa-这么重要的非对称加密算法怎么不在了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#那你可能会问了-之前-rsa-这么重要的非对称加密算法怎么不在了"}},[_._v("#")]),_._v(" 那你可能会问了, 之前 RSA 这么重要的非对称加密算法怎么不在了？")]),_._v(" "),e("p",[_._v("回到 RSA 握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成 "),e("code",[_._v("Client Random")]),_._v(" 并用公钥加密传给服务器，服务器通过私钥解密，从而拿到真实的 "),e("code",[_._v("Client Random")])]),_._v(" "),e("p",[_._v("当中间人拿到了服务器私钥，并且截获之前所有报文的时候，那么就能拿到 "),e("code",[_._v("Client Random")]),_._v(" 和 "),e("code",[_._v("Server Random")]),_._v(" 并根据对应的随机数函数生成 "),e("code",[_._v("Premaster secret")]),_._v(", 最终得到会话密钥。")]),_._v(" "),e("p",[_._v("也就是拿到了 TLS 最终的会话密钥，每一个历史报文都能通过这样的方式进行破解。")]),_._v(" "),e("p",[_._v("但 "),e("code",[_._v("ECDHE")]),_._v(" 在每次握手时都会生成临时的密钥对，即使私钥被破解，之前的历史消息并不会收到影响。这种一次破解并不影响历史信息的性质也叫"),e("strong",[_._v("前向安全性")]),_._v("。")]),_._v(" "),e("p",[e("code",[_._v("RSA")]),_._v(" 算法不具备前向安全性，而 "),e("code",[_._v("ECDHE")]),_._v(" 具备，因此在 TLS1.3 中彻底取代了 RSA。")]),_._v(" "),e("h2",{attrs:{id:"提升性能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提升性能"}},[_._v("#")]),_._v(" 提升性能")]),_._v(" "),e("p",[_._v("HTTPS 建立连接时除了要做 TCP 握手，还要做 TLS 握手，在 1.2 中会多花两个消息往返（2-RTT），可能导致几十毫秒甚至上百毫秒的延迟，在移动网络中延迟还会更严重。")]),_._v(" "),e("h3",{attrs:{id:"握手提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#握手提升"}},[_._v("#")]),_._v(" 握手提升")]),_._v(" "),e("p",[e("img",{attrs:{src:"https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/tsl-13.png",alt:""}})]),_._v(" "),e("p",[_._v("大体的方式和 TLS1.2 差不多，不过和 TLS 1.2 相比少了一个 RTT， 服务端不必等待对方验证证书之后才拿到 client_params，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算 secret，节省了之前不必要的等待时间。同时，这也意味着在第一次握手的时候客户端需要传送更多的信息，一口气给传完。")]),_._v(" "),e("p",[_._v("这种 TLS 1.3 握手方式也被叫做 1-RTT 握手。但其实这种 1-RTT 的握手方式还是有一些优化的空间的，接下来我们来一一介绍这些优化方式。")]),_._v(" "),e("h3",{attrs:{id:"会话复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#会话复用"}},[_._v("#")]),_._v(" 会话复用")]),_._v(" "),e("p",[_._v("会话复用有两种方式: "),e("code",[_._v("Session ID")]),_._v(" 和 "),e("code",[_._v("Session Ticket")]),_._v("。")]),_._v(" "),e("p",[_._v("先说说最早出现的 Seesion ID，具体做法是客户端和服务器首次连接后各自保存会话的 ID，并存储会话密钥，当再次连接时，客户端发送 ID 过来，服务器查找这个 ID 是否存在，如果找到了就直接复用之前的会话状态，会话密钥不用重新生成，直接用原来的那份。")]),_._v(" "),e("p",[_._v("但这种方式也存在一个弊端，就是当客户端数量庞大的时候，对服务端的存储压力非常大。")]),_._v(" "),e("p",[_._v("因而出现了第二种方式——"),e("code",[_._v("Session Ticket")]),_._v("。它的思路就是: 服务端的压力大，那就把压力分摊给客户端呗。具体来说，双方连接成功后，服务器加密会话信息，用 "),e("code",[_._v("Session Ticket")]),_._v(" 消息发给客户端，让客户端保存下来。下次重连的时候，就把这个 Ticket 进行解密，验证它过没过期，如果没过期那就直接恢复之前的会话状态。")]),_._v(" "),e("p",[_._v("这种方式虽然减小了服务端的存储压力，但与带来了安全问题，即每次用一个固定的密钥来解密 Ticket 数据，一旦黑客拿到这个密钥，之前所有的历史记录也被破解了。因此为了尽量避免这样的问题，密钥需要定期进行更换。")])])}),[],!1,null,null,null);v.default=s.exports}}]);