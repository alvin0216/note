---
title: 38. 字符串的排列
date: 2022-04-28 16:35:44
sidebar: auto
tags:
  - 剑指 offer
categories:
  - leetcode
---

> [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

```js
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

## 题解

```js
/**
 * @param {string} s
 * @return {string[]}
 */
var permutation = function (s) {};
```

直接全排序，最后用 Set 去重。唯一得缺点就是没有剪枝...

```js
/**
 * @param {string} s
 * @return {string[]}
 */
var permutation = function (s) {
  if (s.length <= 1) return [s];
  let result = [];
  [...s].forEach((char, index, arr) => {
    let temp = arr.slice();
    temp.splice(index, 1); // 排除当前 char，比如 abc 这里分别会是 a bc，b ac，c ab
    permutation(temp.join('')).forEach((v) => {
      result.push([char, ...v].join(''));
    });
  });

  return [...new Set(result)]; // new Set 排除重复值 比如有可能是 abb 情况
};
```

## 回溯

相似题目

- [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)
- [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)
- [46. 全排列](https://leetcode-cn.com/problems/permutations/)
  - [题解](https://www.bilibili.com/video/BV1pP4y1W7mV?spm_id_from=333.337.search-card.all.click)
  - [题解 2](https://juejin.cn/post/6882394656148045838)
- [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)
  - [题解 & 需要剪枝](https://leetcode-cn.com/problems/permutations-ii/solution/shou-hua-tu-jie-li-yong-yue-shu-tiao-jian-chong-fe/)
- [78. 子集](https://leetcode-cn.com/problems/subsets/)
- [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

:::: tabs

::: tab 46. 全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

```js
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

```js
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

```js
示例 3：

输入：nums = [1]
输出：[[1]]
```

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {};
```

:::

::: tab 答案

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
  let result = [];
  function dfs(path, store) {
    // 判断终止条件
    if (path.length === nums.length) {
      result.push(path);
      return;
    }

    // 遍历每一层
    for (let i = 0; i < store.length; i++) {
      // path ++ & store--
      dfs([...path, store[i]], [...store.slice(0, i), ...store.slice(i + 1)]);
    }
  }

  dfs([], nums);

  return result;
};
```

使用 回溯法：

```js

```

:::

::::
