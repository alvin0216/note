---
title: 零钱兑换
date: 2020-08-28 10:19:16
---

给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回  -1。

```js
输入: coins = [1, 2, 5], amount = 11
输出: 3
解释: 11 = 5 + 5 + 1

输入: coins = [2], amount = 3
输出: -1

你可以认为每种硬币的数量是无限的。

/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {}
```

<h3>题解</h3>

- 假设给出的不同面额的硬币是[1, 2, 5]，目标是 120，问最少需要的硬币个数？
- 我们要分解子问题，分层级找最优子结构，看到这又要晕了哈，憋急~~ 下面马上举例。
- 这里我们使用「**自顶向下**」思想来考虑这个题目，然后用「**自底向上**」的方法来解题，
  体验算法的冰火两重天。
- **dp[i]: 表示总金额为 i 的时候最优解法的硬币数**
- 我们想一下：求总金额 120 有几种方法？下面这个思路关键了 !!!
  一共有 3 种方式，因为我们有 3 种不同面值的硬币。
  1. 拿一枚面值为 1 的硬币 + 总金额为 119 的最优解法的硬币数量
     这里我们只需要假设总金额为 119 的最优解法的硬币数有人已经帮我们算好了，
     不需要纠结于此。(虽然一会也是我们自己算，哈哈)
     即：`dp[119] + 1`
  2. 拿一枚面值为 2 的硬币 + 总金额为 118 的最优解法的硬币数
     这里我们只需要假设总金额为 118 的最优解法的硬币数有人已经帮我们算好了
     即：`dp[118] + 1`
  3. 拿一枚面值为 5 的硬币 + 总金额为 115 的最优解法的硬币数
     这里我们只需要假设总金额为 115 的最优解法的硬币数有人已经帮我们算好了
     即：`dp[115] + 1`
  - 所以，总金额为 120 的最优解法就是上面这三种解法中最优的一种，也就是硬币数最少
    的一种，我们下面试着用代码来表示一下：
  - `dp[120] = Math.min(dp[119] + 1, dp[118] + 1, dp[115] + 1)`;
  - 推导出「状态转移方程」：
    `dp[i] = Math.min(dp[i - coin] + 1, dp[i - coin] + 1, ...)`
    其中 coin 有多少种可能，我们就需要比较多少次，那么我们到底需要比较多少次呢？
    当然是 coins 数组中有几种不同面值的硬币，就是多少次了~ 遍历 coins 数组，
    分别去对比即可
  - 上面方程中的 dp[119]，dp[118]，dp[115] 我们继续用这种思想去分解，
    这就是动态规划了，把这种思想，思考问题的方式理解了，这一类型的题目
    问题都不会太大。

```js
var coinChange = function(coins, amount) {
  let dp = new Array(amount + 1).fill(Infinity)
  dp[0] = 0

  for (let coin of coins) {
    // 要凑出金额 n，至少要 dp(n) 个硬币
    for (let i = coin; i <= amount; i++) {
      // 做选择，选择需要硬币最少的那个结果
      dp[i] = Math.min(dp[i], dp[i - coin] + 1)
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount]
}

// dp [Infinity, Infinity, ....] amount + 1 个
// dp[amount] 为最小解
```

![](https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F5381a5e30482682c1c6f111e882991113b8661f7.png?alt=media)
