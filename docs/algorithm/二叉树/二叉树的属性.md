---
title: 二叉树题目集合
date: 2022-03-31 20:46:00
sidebar: auto
tags:
  - 二叉树
categories:
  - leetcode
---

## 对称二叉树

[leetcode](https://leetcode-cn.com/problems/symmetric-tree/): 给你一个二叉树的根节点 root，检查它是否轴对称。

![](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```js
输入：root = [1,2,2,3,4,4,3]
输出：true
```

code:

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
  const check = (left, right) => {
    if (!left && !right) return true; // 左右子树都不存在 也是对称的
    if (left && right) {
      // 左右子树都存在，要继续判断
      return (
        left.val === right.val && // 左右子树的顶点值要相等
        check(left.left, right.right) && // 左子树的left和右子树的right相等
        check(left.right, right.left) // 左子树的right和右子树的left相等
      );
    }
    // 左右子树中的一个不存在，一个存在，不是对称的
    return false;
  };
  return !root || check(root.left, root.right); // root为null也是对称的
};
```

## 二叉树的最大深度

[leetcode](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)： 给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

```js
    3
   / \
  9  20
    /  \
   15   7
//  3
```

我的答案：

```js
var maxDepth = function (root) {
  let deep = 0;
  function dfs(node, len) {
    if (node) {
      deep = Math.max(deep, len + 1);
      node.left && dfs(node.left, len + 1);
      node.right && dfs(node.right, len + 1);
    }
  }

  dfs(root, 0);
  return deep;
};
```

别人的答案：

```js
var maxDepth = function (root) {
  if (!root) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

## 二叉树的最小深度

[leetcode](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)：给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {
  if (!root) return 0;
  // 到叶子节点 返回 1 终止条件！
  if (!root.left && !root.right) return 1;
  // 只有右节点时 递归右节点
  if (!root.left) return 1 + minDepth(root.right);
  // 只有左节点时 递归左节点
  if (!root.right) return 1 + minDepth(root.left);
  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
};
```

## 平衡二叉树

[leetcode](https://leetcode-cn.com/problems/balanced-binary-tree/)：给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

**一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。**

![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

true

![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)

false

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {
  if (!root) return true;
  if (Math.abs(getDeep(root.left) - getDeep(root.right)) > 1) return false;
  return isBalanced(root.left) && isBalanced(root.right);
};

function getDeep(node) {
  if (!node) return 0;
  return 1 + Math.max(getDeep(node.left), getDeep(node.right));
}
```
