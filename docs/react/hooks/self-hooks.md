---
title: 你怎么封装 hooks 的
date: 2020-09-25 11:36:02
---

封装 hooks 原则：高内聚低耦合、抽象来说就是做到 UI 和逻辑分离。

## 考虑功能

比如我公司项目有个撤销工具（这里面用到的是栈，通过 `context` 存储坐标数据）, 那么这个组件会需要做到什么功能呢？封装成 `hooks` 对比 `hoc` 又有什么好处呢？

1. 撤销工具，首先这里会存储操作过后的坐标点，操作后的坐标点数据时入栈和出栈。
2. 在入栈和出栈都会调用图像端的方法更新视图。
   1. 内部其实会通过 new 一个实例，在摧毁组件时也会移除相应的监听
   2. 通过这个实例去读取相应的图像操作方法

这里可以确定会用到 2 个 `hoc` 了，
第一个就是封装图像操作的高阶组件
第二个就是撤销栈的操作工具

## 为什么不放在一个 hoc 以及弊端

也就是说同个组件，我需要调用撤销工具我就需要混入两个 hoc，其实可以思考为什么不放在一起封装成一个 hoc？

1. 违背**单一职责**的的设计原则，会让组件变得不好维护。
2. 可以料想一下我的工具可不止这一个。其他的还有例如复制轮廓、切割轮廓、填充等等…如果写在一个 hoc，首先会导致一个代码耦合过高，第二个重复渲染问题。
3. 第二点我在调用复制轮廓的时候，会检查是否进行过操作，也就是检查撤销工具里的栈是否有数据，考虑 `hoc` 会增多一个嵌套工具了，也就要多一层 `hoc` …这样下去的嵌套只会越来越深，如果我代码出问题了，我需要在组件里找问题，然后一个个 `hoc` 里找，这个方法是来源于哪里….
4. 第三点就是我其他地方需要用到，那么我也是要通过 hoc 去嵌套组件的

## 私有 hooks 分散逻辑

于是利用 hooks 可以将它的聚合变得分散，我可以单独将撤销工具封装一个 hooks，将图像工具做成一个 hooks，将切割轮廓写出一个 hooks，值得一提的是，hooks 里面可以调用的其他 hooks 的，所以非常方便…

这就是我封装 hooks 的一个思路。入参和出参的话，hooks 我只暴露我需要的方法，内部逻辑还是聚合在里面。…
