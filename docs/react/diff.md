---
title: React Diff 算法
date: 2021-06-29 10:54:23
sidebar: auto
tags:
  - React
  - React Diff
categories: React
---

Diff 算法：基本概念、更新时机 、遍历算法、优化策略

## 基本概念

**（基本概念）** diff 算法是建立在虚拟 dom 的基础上的，diff 算法探讨的就是虚拟 dom 发生变化之后生成 dom 树更新补丁的方式，通过对比新旧虚拟 dom 的方式，将更新 patch 补丁作用到真实 dom 中，以最小的成本完成视图更新。

**（大概流程）** 首先真实的 dom 会映射到虚拟 dom 中，当虚拟 dom 发生变化后，会根据差异计算生成 patch、包括新增、删除、更新。

## 更新时机

更新时机：setState、hooks 等

## 遍历算法

遍历算法：深度优先遍历，从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止然后回溯前一个节点，进行右子树节点遍历，直到遍历完所有可达节点

**为什么用深度不用广度**：虽然深度优先遍历保证了组件的生命周期时序不错乱，但传统的 diff 算法带来一个严重的性能瓶颈，复杂程度为 0(n^3),其中 n 表示树的节点总数

React 用了一个非常经典的手法将复杂度降低为 0(n)就是分治，即通过“分而治之”这一-巧妙的思想分解问题

## 优化策略

具体而言 react 从 `树` `组件` `元素` 三个层面进行优化

![](https://user-images.githubusercontent.com/34113677/158239575-a5262d59-9bff-400f-a507-116aada46082.png)

**策略一:忽略节点跨层级操作场景，提升比对效率**

需进行树比对，即对树进行分层比较两棵树只对同一层次节点进行比较，如发现节点已不存在则该节点及其子节点会被完全删除，不会用于进一步比较，提升了比对效率

**策略二:如果组件的 class 一致，则默认为相似的树结构否则默认为不同的树结构**

如果组件是同一类型则进行树比对如果不是则直接放入补丁中。这也是 `shouldComponentUpdate` `React.memo` 能提高性能的原因。

**策略三:同一层级子节点，可通过标记 key 的方式进行列表对比**

元素比对主要发生在同层级中，通过标记节点操作生成补丁节点操作包含了插入、移动、删除等

**除此之外，还采用了双缓冲机制**

- Fiber 机制下节点与树分别采用 FiberNode 与 FiberTree 进行重构
  - FiberNode 是采用了双链表的结构、可以直接找到兄弟节点和字节点，使得整个更新过程可以随时暂停恢复
  - FiberTree 则是通过 FiberNode 生成的树。
- Fiber 机制下整个更新过程由 current 与 workInProgress 两株树双缓冲完成
  - 当 workInProgress 树更新完成后，会将 current 指针指向 workInProgress

## 了解 diff 算法，我们该怎么做

- 根据 diff 算法的设计原则,应尽量避免跨层级节点移动。
- 通过设置唯一 key 进行优化，尽量减少组件层级深度，因为过深的层级会加深遍历深度，带来性能问题。
- 设置 shouldComponentUpdate 或者 React.pureComponet 减少 diff 次数
