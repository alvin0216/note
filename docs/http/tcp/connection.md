---
title: 三次握手
---

通过上节 我们知道 IP 可能是通过 DNS 解析拿到的。

HTTP 协议是运行在 TCP/IP 基础上的，依靠 TCP/IP 协议来实现数据的可靠传输。所以浏览器要用 HTTP 协议收发数据，首先要做的就是建立 TCP 连接。

## TCP 报文

TCP 报文是 TCP 层传输的数据单元，也叫报文段。

![](https://gitee.com/alvin0216/cdn/raw/master/img/http/tcp-msg.png)

1. 序号（`sequence number`）: Seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。
2. 确认号（`acknowledgement number`）：Ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，`Ack=Seq+1`。
3. 标志位 <span class='orange'>flags</span> ：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下
   - `URG`：紧急指针（urgent pointer）有效。
   - `ACK`：确认序号有效。
   - `PSH`：接收方应该尽快将这个报文交给应用层。
   - `RST`：重置连接。
   - `SYN`：发起一个新连接。
   - `FIN`：释放一个连接。

## 三次握手

TCP 的三次握手，也是需要确认双方的两样能力: 发送的能力和接收的能力。于是便会有下面的三次握手的过程:

![](https://gitee.com/alvin0216/cdn/raw/master/img/http/shake-hand.png)

刚开始客户端处于 `Closed` 的状态，服务端处于 `Listen` 状态。 进行三次握手：

| 握手 | 描述                                                                                                                                                                                                                                               |
| ---- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1️⃣   | 客户端给服务端发一个 `SYN` 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 `SYN_SEND` 状态。                                                                                                                                               |
| 2️⃣   | 服务器收到客户端的 SYN 报文之后，会以自己的 `SYN + ACK` 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。 同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 `SYN_REVD` 的状态。                         |
| 3️⃣   | 客户端收到 SYN 报文之后，会发送一个 `ACK` 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态，此时，双方已建立起了连接。 |

从图中可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加 1，为什么呢？只需要记住一个规则:

> 凡是需要对端确认的，一定消耗 TCP 报文的序列号。

## 为什么需要三次握手，两次不行吗？

试想如果是用两次握手，则会出现下面这种情况：

如果是两次，你现在发了 SYN 报文想握手，但**是这个包滞留在了当前的网络中**迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。

看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。

看到问题的吧，这就带来了连接资源的浪费。

## 三次握手过程中可以携带数据吗？

**第三次握手的时候，可以携带。前两次握手不能携带数据。**

如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。

第三次握手的时候，客户端已经处于 `ESTABLISHED` 状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

## 同时打开会怎样？

如果双方同时发 `SYN` 报文，状态变化会是怎样的呢？

这是一个可能会发生的情况。

状态变迁如下:

<img className='small' alt='' src='https://gitee.com/alvin0216/cdn/raw/master/img/http/tcp-connection.png' />

在发送方给接收方发 `SYN` 报文的同时，接收方也给发送方发 `SYN` 报文，两个人刚上了!

发完 SYN，两者的状态都变为 `SYN-SENT`。

在各自收到对方的 `SYN` 后，两者状态都变为 `SYN-REVD`。

接着会回复对应的 `ACK + SYN`，这个报文在对方接收之后，两者状态一起变为 `ESTABLISHED`。

这就是同时打开情况下的状态变迁。
