---
title: 怎么解决队头阻塞问题？
date: 2020-06-10 18:00:57
---

HTTP 队头阻塞：HTTP 请求是有先后顺序的，报文必须是一发一收， 里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。

## 解决 HTTP 队头阻塞

<blockquote class='box'>

**HTTP/1.1**

- 并发连接: 也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。
- 域名分片: 一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。

</blockquote>

<blockquote class='box'>

**HTTP/2.0**

多路复用：对报文进行了头部压缩和二进制分帧，以流的方式无序传输，流是可并发的彼此不依赖，所以没有队头阻塞。

</blockquote>

HTTP/2 底层还是依赖 TCP 传输，没有解决队头阻塞的问题啊，这就是为何 HTTP/3 要基于 UDP 来传输的原因。

## 解决 TCP 队头阻塞

这是因为 HTTP/2 虽然使用“帧”“流”“多路复用”，没有了“队头阻塞”，但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”

客户端用 TCP 发送了三个包，但服务器所在的操作系统只收到了后两个包，第一个包丢了。那么内核里的 TCP 协议栈就只能把已经收到的包暂存起来，“停下”等着客户端重传那个丢失的包，这样就又出现了“队头阻塞”。

<blockquote class='box'>

**HTTP/3**

QUIC 协议： 把下层的 TCP“抽掉”了，换成了 UDP。因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。

此外还有一个 SCTP（流控制传输协议），它是和 TCP、UDP 在同一层次的传输协议。SCTP 的多流特性也可以尽可能的避免队头阻塞的情况。

</blockquote>

## 补充

<blockquote class='box'>

http/1.1 一个 tcp 同时只能处理一个请求，浏览器会为每个域名维护 6 个 tcp 连接！

但是每个 tcp 连接是可以复用的，也就是处理完一个请求之后，不断开这个 tcp 连接，可以用来处理下个 http 请求！

不过 http2 是可以并行请求资源的，所以如果使用 http2，浏览器只会为每个域名维护一个 tcp 连接

</blockquote>
