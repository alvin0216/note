---
title: HTTPS 和 SSL/TLS
date: 2020-06-05 22:54:50
---

## HTTP 存在的问题

- 1️⃣ **可能被窃听**
  - HTTP 本身不具备加密的功能,HTTP 报文使用明文方式发送
  - 由于互联网是由联通世界各个地方的网络设施组成,所有发送和接收经过某些设备的数据都可能被截获或窥视。(例如大家都熟悉的抓包工具:`Wireshark`)
- 2️⃣ **认证问题**
  - 无法确认你发送到的服务器就是真正的目标服务器(可能服务器是伪装的)
  - 无法确定返回的客户端是否是按照真实意图接收的客户端(可能是伪装的客户端)
  - 无法确定正在通信的对方是否具备访问权限，Web 服务器上某些重要的信息，只想发给特定用户即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。
- 3️⃣ **可能被篡改**
  - 请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击被称为中间人攻击（Man-in-the-Middle attack，MITM）。

## HTTPS

> 超文本传输<span class='orange'>安全</span>协议, 默认端口号 `443`。是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 `SSL/TLS` 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

`HTTPS` 把 HTTP 下层的传输协议由 `TCP/IP` 换成了 `SSL/TLS`，由“HTTP over TCP/IP”变成了“HTTP over SSL/TLS”，让 HTTP 运行在了安全的 SSL/TLS 协议上。

![](../../assets/http/series/https.png)

## SSL/TLS

SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。

SL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。

TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。

HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：<span class='orange'>散列函数</span> 、<span class='orange'>对称加密</span> 和 <span class='orange'>非对称加密</span>，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。

![](../../assets/http/series/ssl.png)

按照密钥的使用方式，加密可以分为两大类：**对称加密**和**非对称加密**。

### 对称加密

对称加密就是我有个加密算法 F1，还有一个加密的密钥 K，数据为 data。经过运算后得到一个密文 X。

对应的解密算法 F2，相同的密钥 K，通过运算后解密获得数据。下面是一段伪代码：

```js
F1(k, data) = x // 加密获得密文  常见算法有 `AES` `DES` `RC4` 等

F2(k, x) = data // 解密获得数据
```

![](../../assets/http/series/symmetric-encryption.png)

比如客户端给服务端发送数据给服务端 -> 使用 <span class='orange'>密钥加密</span> 发送密文给服务端 -> 服务端拿到密文后使用 <span class='orange'>相同的密钥解密</span> 获取数据

对称加密看上去好像完美地实现了机密性，但其中有一个很大的问题：如何把密钥安全地传递给对方，术语叫“**密钥交换**”。

### 非对称加密

因为**在对称加密算法中只要持有密钥就可以解密**。如果你和网站约定的密钥在传递途中被黑客窃取，那他就可以在之后随意解密收发的数据，通信过程也就没有机密性可言了。

所以，就出现了`非对称加密`（也叫公钥加密算法）。

它有两个密钥，一个叫“`公钥`”（public key），一个叫“`私钥`”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。

非对称加密可以解决“密钥交换”的问题。网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。

- 任何经过 A 的公钥进行加密的信息，只有 A 的私钥才能解密
- 任何有公钥的人可以确认对方发送的消息是被私钥加密过的
- 非对称加密解密计算开销远远大于对称加密

```js
// 非对称加密算法的设计要比对称算法难得多，在 TLS 里只有很少的几种，比如 DH、DSA、RSA、ECC 等。
// f 常见 RSA 算法, 它的安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。

// 第一步客户端发送请求，索要公钥，将公钥要回来
f(publicKey, data) = Y // 通过公钥加密
f(privateKey, Y) = data // 通过私钥解密

// 反过来
f(privateKey, data) = Y // 通过私钥加密
f(publicKey, Y) = data // 通过公钥解密
```

![](../../assets/http/series/asymmetric.png)

非对称加密算法的设计要比对称算法难得多，在 TLS 里只有很少的几种，比如 DH、DSA、RSA、ECC 等。

比如 客户端给服务端发送数据

1. 通过公钥加密得到密文 Y，发送数据给服务端
2. 服务端既有公钥也有私钥，这时候可以通过私钥进行解密得到数据。

这样即使黑客截获了密文 Y，也无法进行解密。**那么服务端返回数据给客户端怎么做呢？**

通过公钥加密的密文发送给客户端，然而客户端没有密钥，解密不出来。上面的伪代码也写了，也可以通过私钥加密，公钥解密，问题来了，黑客也可以截取这次通过私钥加密的密文，黑客也可以通过公钥进行解密获取 data。显然，非对称加密的方法也不是完美的

---

### 混合加密

- 对称加密：密钥 k 只有一个，被截胡了就完蛋了。
- 非对称加密：客户端发送数据给服务端是安全的，服务端给客户端发送数据的时候是不安全的。

所以需要结合两个算法的优点进行制定新的加密方案：

1. 先利用非对称加密的方式在服务端和客户端之间达成协商，协商出一个临时的 k。
2. 再利用这个 k 进行对称加密，进行数据的交互。那么每个服务端对客户端的 k 都不同。

![](../../assets/http/series/hybrid-encryption2.png)

在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。

然后用随机数产生对称算法使用的“`会话密钥`”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。

对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。

### 摘要算法

> 摘要算法: 特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。
> 因为摘要算法对输入具有“单向性”和“雪崩效应”，输入的微小不同会导致输出的剧烈变化，所以也被 TLS 用来生成伪随机数

请看下一节 [数字签名与证书](./certificate.md)

参考

- [分分钟让你理解 HTTPS](https://juejin.im/post/5ad6ad575188255c272273c4)
- [阮一峰 SSL/TLS 协议运行机制的概述](https://ruanyifeng.com/blog/2014/02/ssl_tls.html)
- [阮一峰 RSA 算法原理（一）](https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)
- [阮一峰 RSA 算法原理（二）](https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)
