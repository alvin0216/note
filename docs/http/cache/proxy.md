---
title: 代理缓存
---

首先通过 `Cache-Control` 验证强缓存是否可用

- 如果强缓存可用，直接使用
- 否则进入协商缓存，即发送 HTTP 请求。
  - 检查 `Etag/If-None-Match` 是否一致 一致则缓存可用，返回 `304 Not Modified`
  - 检查 `Last-Modified/If-Modified-Since` 是否一致 一致则缓存可用，返回 `304 Not Modified`

## 为什么产生代理缓存？

对于源服务器来说，它也是有缓存的，比如 Redis, Memcache，但对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。

由此引入了缓存代理的机制。让代理服务器接管一部分的服务端 HTTP 缓存，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。

那缓存代理究竟是如何做到的呢？

总的来说，缓存代理的控制分为两部分，一部分是**源服务器端**的控制，一部分是**客户端的控制**。

## 源服务器的缓存控制

### private 和 public

在源服务器的响应头中，会加上 `Cache-Control` 这个字段进行缓存控制字段，那么它的值当中可以加入 `private` 或者 `public` 表示是否允许代理服务器缓存，前者禁止，后者为允许。

比如对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头部的 `Cache-Control` 设为 `private`，而不是 `public`。

### must-revalidate 和 proxy-revalidate

`must-revalidate` 的意思是客户端缓存过期就去源服务器获取，而 `proxy-revalidate` 则表示代理服务器的缓存过期后到源服务器获取

### s-maxage

`s` 是 `share` 的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的 `max-age` 并不冲突。

讲了这几个字段，我们不妨来举个小例子，源服务器在响应头中加入这样一个字段:

```yml
Cache-Control: public, max-age=1000, s-maxage=2000
```

相当于源服务器说: 我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理中拿，并且在客户端的缓存时间为 1000 秒，在代理服务器中的缓存时间为 2000 s。

## 客户端的缓存控制

### max-stale 和 min-fresh

在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行宽容和限制操作。比如：

```yml
max-stale: 5
```

表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在 5 秒之内，还是可以从代理中获取的。

又比如:

```jml
min-fresh: 5
```

表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前 5 秒之前的时间拿，否则拿不到。

### only-if-cached

这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回 `504（Gateway Timeout）`。

---

参考 [神三元（建议精读）HTTP 灵魂之问，巩固你的 HTTP 知识体系](https://juejin.im/post/5e76bd516fb9a07cce750746)
